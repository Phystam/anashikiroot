// -*- mode: c++ -*-
// 
// File MDF.C generated by TMultiDimFit::MakeRealCode
// on Thu Mar  2 19:30:12 2017
// ROOT version 5.34/30
//
// This file contains the function 
//
//    double  MDF(double *x); 
//
// For evaluating the parameterization obtained
// from TMultiDimFit and the point x
// 
// See TMultiDimFit class documentation for more information 
// 
//
// Static data variables
//
static int    gNVariables    = 6;
static int    gNCoefficients = 43;
static double gDMean         = 7.01777;
// Assignment to mean vector.
static double gXMean[] = {
  0.0121148, 0.0283438, 0.00611092, 0.0094724, 0.0018743, 0.186765 };

// Assignment to minimum vector.
static double gXMin[] = {
  -107.967, -0.0397556, -84.9428, -0.0399876, -879.88, -0.0772925 };

// Assignment to maximum vector.
static double gXMax[] = {
  108.305, 0.0402202, 83.9388, 0.0396994, 800.388, 0.329739 };

// Assignment to coefficients vector.
static double gCoefficient[] = {
  -0.424339,
  1.67789,
  0.332713,
  0.305979,
  -0.135572,
  -0.0721505,
  0.029613,
  0.0747253,
  -0.028293,
  -0.0190215,
  0.0563052,
  0.03935,
  -0.0204665,
  -0.0413144,
  -0.0302886,
  0.00626792,
  0.0090429,
  -0.0208276,
  -0.00082504,
  0.00318141,
  0.00749878,
  -0.00765325,
  -0.00057057,
  -0.00591177,
  0.00111637,
  0.00115695,
  0.00296675,
  -0.0035012,
  0.00205999,
  -0.00132634,
  -0.0185052,
  0.0159739,
  0.000721355,
  -0.000839687,
  0.00204082,
  0.000535906,
  0.000978837,
  -0.00156091,
  0.000849613,
  -0.00184237,
  0.0020994,
  0.00155229,
  -0.000244161
 };

// Assignment to error coefficients vector.
static double gCoefficientRMS[] = {
  0.0285414,
  0.0612406,
  0.106047,
  0.064641,
  0.0929886,
  0.0745704,
  0.16233,
  0.267159,
  0.0811129,
  0.0461675,
  0.126283,
  0.109628,
  0.217277,
  0.175011,
  0.205346,
  0.0990003,
  0.0925405,
  0.369784,
  0.0623629,
  0.138024,
  0.135281,
  0.168412,
  0.0737257,
  0.310467,
  0.105808,
  0.164102,
  0.234192,
  0.370603,
  0.265779,
  0.348921,
  0.937609,
  0.904847,
  0.0788534,
  0.0877558,
  0.2605,
  0.149214,
  0.157575,
  0.187575,
  0.170092,
  0.160217,
  0.335023,
  0.298887,
  0.12349
 };

// Assignment to powers vector.
// The powers are stored row-wise, that is
//  p_ij = gPower[i * NVariables + j];
static int    gPower[] = {
  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  2,
  2,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  3,
  1,  2,  1,  1,  2,  1,
  3,  1,  1,  1,  1,  1,
  1,  1,  3,  1,  1,  1,
  1,  1,  2,  2,  1,  1,
  1,  2,  1,  1,  1,  1,
  1,  3,  1,  1,  1,  1,
  1,  1,  1,  3,  1,  1,
  1,  1,  1,  1,  1,  4,
  1,  2,  2,  2,  1,  1,
  1,  2,  1,  1,  1,  3,
  2,  2,  1,  1,  1,  2,
  1,  1,  3,  1,  2,  1,
  1,  1,  1,  3,  1,  2,
  2,  1,  2,  2,  1,  1,
  1,  1,  1,  2,  1,  1,
  2,  3,  1,  1,  1,  1,
  1,  3,  1,  1,  2,  1,
  1,  2,  1,  3,  1,  1,
  1,  1,  2,  1,  1,  1,
  2,  1,  3,  1,  1,  1,
  2,  1,  1,  1,  1,  2,
  2,  1,  1,  2,  1,  1,
  2,  1,  1,  1,  3,  1,
  3,  1,  1,  2,  1,  1,
  1,  2,  1,  2,  2,  1,
  2,  1,  1,  2,  2,  1,
  2,  1,  2,  1,  1,  2,
  2,  1,  2,  1,  2,  1,
  1,  1,  1,  2,  1,  2,
  1,  1,  2,  1,  1,  2,
  2,  1,  2,  1,  1,  1,
  1,  2,  2,  1,  1,  1,
  4,  1,  1,  1,  1,  1,
  1,  1,  2,  1,  3,  1,
  1,  1,  1,  2,  3,  1,
  1,  3,  2,  1,  1,  1,
  2,  2,  1,  2,  1,  1,
  1,  2,  2,  1,  1,  2,
  1,  2,  1,  2,  1,  1
};

// 
// The function   double MDF(double *x)
// 
double MDF(double *x) {
  double returnValue = gDMean;
  int    i = 0, j = 0, k = 0;
  for (i = 0; i < gNCoefficients ; i++) {
    // Evaluate the ith term in the expansion
    double term = gCoefficient[i];
    for (j = 0; j < gNVariables; j++) {
      // Evaluate the polynomial in the jth variable.
      int power = gPower[gNVariables * i + j]; 
      double p1 = 1, p2 = 0, p3 = 0, r = 0;
      double v =  1 + 2. / (gXMax[j] - gXMin[j]) * (x[j] - gXMax[j]);
      // what is the power to use!
      switch(power) {
      case 1: r = 1; break; 
      case 2: r = v; break; 
      default: 
        p2 = v; 
        for (k = 3; k <= power; k++) { 
          p3 = p2 * v;
          p1 = p2; p2 = p3; 
        }
        r = p3;
      }
      // multiply this term by the poly in the jth var
      term *= r; 
    }
    // Add this term to the final result
    returnValue += term;
  }
  return returnValue;
}

// EOF for MDF.C
