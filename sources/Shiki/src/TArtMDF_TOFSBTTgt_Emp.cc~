// -*- mode: c++ -*-
// 
// File TArtMDF_TOFSBTTgt_EmpMDF.cxx generated by TMultiDimFit::MakeRealCode
// on Mon Dec 11 20:57:31 2017
// ROOT version 5.34/30
//
// This file contains the function 
//
//    double  TArtMDF_TOFSBTTgt_Emp::MDF(double *x); 
//
// For evaluating the parameterization obtained
// from TMultiDimFit and the point x
// 
// See TMultiDimFit class documentation for more information 
// 
#include "TArtMDF_TOFSBTTgt_Emp.h"
//
// Static data variables
//
int    TArtMDF_TOFSBTTgt_Emp::gNVariables    = 3;
int    TArtMDF_TOFSBTTgt_Emp::gNCoefficients = 31;
double TArtMDF_TOFSBTTgt_Emp::gDMean         = 15.6399;
// Assignment to mean vector.
double TArtMDF_TOFSBTTgt_Emp::gXMean[] = {
  0.0714286, 0.166667, -0.164547 };

// Assignment to minimum vector.
double TArtMDF_TOFSBTTgt_Emp::gXMin[] = {
  27, 9, 175.088 };

// Assignment to maximum vector.
double TArtMDF_TOFSBTTgt_Emp::gXMax[] = {
  34, 11, 213.407 };

// Assignment to coefficients vector.
double TArtMDF_TOFSBTTgt_Emp::gCoefficient[] = {
  0.2587,
  1.60679,
  0.0142304,
  -0.00602772,
  0.0108621,
  0.00941044,
  -0.00395306,
  -0.00323333,
  0.00228623,
  -0.00265339,
  0.00580895,
  0.00120183,
  -0.0031222,
  0.000444875,
  -0.00060963,
  -0.00171589,
  -0.000144324,
  -0.00134828,
  0.0011528,
  0.000474449,
  0.000298336,
  -0.000729959,
  0.000198284,
  -0.000260737,
  3.75114e-05,
  0.000216653,
  -0.000121463,
  -0.00011197,
  0.000161691,
  -0.000123222,
  1.58605e-06
 };

// Assignment to error coefficients vector.
double TArtMDF_TOFSBTTgt_Emp::gCoefficientRMS[] = {
  0.236246,
  0.532018,
  0.18163,
  0.554791,
  0.896706,
  0.497716,
  0.974345,
  0.78391,
  0.428024,
  0.55546,
  1.44954,
  0.822615,
  0.956206,
  0.271256,
  1.795,
  0.926216,
  0.795998,
  0.903784,
  1.28823,
  0.55774,
  0.690866,
  1.26039,
  0.772751,
  1.70194,
  0.62437,
  1.41705,
  1.05783,
  1.20257,
  1.84711,
  1.75487,
  0.925723
 };

// Assignment to powers vector.
// The powers are stored row-wise, that is
//  p_ij = TArtMDF_TOFSBTTgt_Emp::gPower[i * NVariables + j];
int    TArtMDF_TOFSBTTgt_Emp::gPower[] = {
  1,  1,  1,
  1,  1,  2,
  1,  2,  1,
  2,  1,  1,
  1,  1,  3,
  1,  2,  2,
  2,  1,  2,
  2,  2,  1,
  1,  2,  3,
  2,  3,  1,
  3,  1,  1,
  1,  1,  4,
  5,  1,  1,
  1,  3,  1,
  2,  1,  3,
  2,  2,  2,
  4,  1,  2,
  2,  3,  2,
  3,  1,  2,
  4,  1,  1,
  1,  5,  2,
  3,  2,  3,
  1,  2,  4,
  2,  2,  3,
  1,  3,  3,
  3,  1,  4,
  1,  3,  4,
  2,  1,  4,
  3,  1,  3,
  2,  1,  5,
  1,  1,  5
};

// 
// The method   double TArtMDF_TOFSBTTgt_Emp::MDF(double *x)
// 
double TArtMDF_TOFSBTTgt_Emp::MDF(double *x) {
  double returnValue = TArtMDF_TOFSBTTgt_Emp::gDMean;
  int    i = 0, j = 0, k = 0;
  for (i = 0; i < TArtMDF_TOFSBTTgt_Emp::gNCoefficients ; i++) {
    // Evaluate the ith term in the expansion
    double term = TArtMDF_TOFSBTTgt_Emp::gCoefficient[i];
    for (j = 0; j < TArtMDF_TOFSBTTgt_Emp::gNVariables; j++) {
      // Evaluate the polynomial in the jth variable.
      int power = TArtMDF_TOFSBTTgt_Emp::gPower[TArtMDF_TOFSBTTgt_Emp::gNVariables * i + j]; 
      double p1 = 1, p2 = 0, p3 = 0, r = 0;
      double v =  1 + 2. / (TArtMDF_TOFSBTTgt_Emp::gXMax[j] - TArtMDF_TOFSBTTgt_Emp::gXMin[j]) * (x[j] - TArtMDF_TOFSBTTgt_Emp::gXMax[j]);
      // what is the power to use!
      switch(power) {
      case 1: r = 1; break; 
      case 2: r = v; break; 
      default: 
        p2 = v; 
        for (k = 3; k <= power; k++) { 
          p3 = p2 * v;
          p1 = p2; p2 = p3; 
        }
        r = p3;
      }
      // multiply this term by the poly in the jth var
      term *= r; 
    }
    // Add this term to the final result
    returnValue += term;
  }
  return returnValue;
}

// EOF for TArtMDF_TOFSBTTgt_EmpMDF.cxx
